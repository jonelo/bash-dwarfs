#!/usr/bin/env bash
#
# update_jre 1.1.0
#
# This script downloads the latest tzupdater from oracle.com and
# updates the tzupdater.jar in the directory where this script is stored.
# The script accepts the license at
# http://www.oracle.com/technetwork/java/javase/terms/license/index.html
# for you. Please don't run the script if you don't agree with it.
#
# Copyright 2018 Johann N. Loefflmann
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Explicitly set the PATH
PATH="/sbin:/usr/sbin:/bin:/usr/bin"
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"


usage() {
cat << END
update_jre v1.1.0, Copyright 2018 Johann N. Loefflmann

Downloads the latest JRE or JDK tarball from the web, extracts it and
creates a symlink called jre_latest resp. jdk_latest.

Usage:
    update_jre [ [-h] | -a [-d] [-f] [-k] [-t type] [path] ]

Options:
    -a      accept license. That is a required option if you want to
            download the JRE or JDK from the site. Please read the license at
            www.oracle.com/technetwork/java/javase/terms/license/index.html
            and allow the script to download the JRE by specifying this option.

    -d      dry run. Don't download the JRE or JDK, just inform me.

    -f      force. Even if we have the JRE already, update it again.

    -h      prints this help.

    -k      keep the downloaded .tar.gz, don't remove it at the end.

    -t      type. Can be jre (the JRE), sjre (server JRE) or jdk (the JDK).

Parameters:
    path    specifies the path where the JRE should be stored.
            It will be created if it doesn't exist.
            If omitted, .jre/ will be used.

Examples:
    update_jre -a
            updates the JRE in ./jre/ and it creates a symlink called
            jre_latest there.
    update_jre -a -t jdk /opt/java/jdk
            updates the JDK in /opt/java/jdk/ and it creates a symlink
            called jdk_latest there.
END
exit 0
}

function detectOStag() {
    # What OS are we running on?
    local OS="$(uname -s)"
    case "$OS" in
        Darwin)
            OS_TAG="osx"
            ;;
        Linux)
            OS_TAG="linux"
            ;;
        Solaris)
            OS_TAG="solaris"
            ;;
        *)
            printf "ERROR: Not supported on %s\n" "$OS"
            exit 1
            ;;
    esac
}

function licenseAcceptedRequired() {
    if [ $1 -eq 0 ]; then
cat << EOM

ERROR: In order to allow this script to download the JRE, please read and
       accept the license at

       http://www.oracle.com/technetwork/java/javase/terms/license/index.html

       by specifying the -a option to this script.

       Use option -h to get more help.

EOM
        exit 1
    fi

}

# Download a webpage and store it to a file
# param1: the website
# param2: the file
function downloadWebsite() {
    local WEBSITE="$1"
    local OUTFILE="$2"

    printf "INFO: Downloading %s and storing it to %s ...\n" "${WEBSITE}" "${OUTFILE}"
    if [ -f "$OUTFILE" ]; then
        rm "$OUTFILE"
    fi
    curl -o "$OUTFILE" "$WEBSITE"
    if [ ! -f "$OUTFILE" ]; then
        printf "FATAL: Download of webpage %s failed. Please check your internet connection.\n" "${WEBSITE}"
        exit 1
    fi
}

# Parse a file
# param1: the file
# param2: the regex
function parseFile() {
    local INFILE="$1"
    local REGEX=$2
    if [ -f "$INFILE" ]; then
        HTML=$(<"$INFILE")
    fi
    if [[ "$HTML" =~ $REGEX ]]; then
        FOUND_ADDRESS="${BASH_REMATCH[1]}"
        printf "INFO: Found %s in %s\n" "${FOUND_ADDRESS}" "${INFILE}"
    else
        printf "FATAL: Actual download address was not found in content of %s\n" "${INFILE}"
        exit 1
    fi
}

function main() {
    detectOStag

    # options
    ACCEPT=0
    DRYRUN=0
    FORCE=0
    KEEP=0
    TYPE="jre"
    while getopts ':afkht:d' OPTION
    do
        case $OPTION in
            a) ACCEPT=1
               ;;
            d) DRYRUN=1
               ;;
            f) FORCE=1
               ;;
            k) KEEP=1
               ;;
            t) TYPE="$OPTARG"
	           if [ "$TYPE" != "jre" ] && [ "$TYPE" != "sjre" ] && [ "$TYPE" != "jdk" ]; then
                   printf "ERROR: -t %s is not supported.\n" "$TYPE"
                   exit 1
               fi
               if [ "$OS_TAG" = "osx" ] && [ "$TYPE" = "sjre" ]; then
                   printf "ERROR: A Server JRE is not supported on macOS.\n" "$TYPE"
                   exit 1
               fi
               if [ "$OS_TAG" = "osx" ] && [ "$TYPE" = "jdk" ]; then
                   printf "ERROR: a JDK .tar.gz is not supported on macOS.\n" "$TYPE"
                   exit 1
               fi
               ;;
            h) usage
               ;;
            ?) printf "ERROR: Option -%s is not a supported option.\n" "$OPTARG"
               exit 1
               ;;
        esac
    done
    shift $(($OPTIND -1))
    licenseAcceptedRequired $ACCEPT

    # parameters
    case $# in
        0) TARGET_DIR="${SCRIPT_DIR}/.${TYPE}"
           ;;
        1) TARGET_DIR="$1"
           ;;
        *) printf "ERROR: none or one parameters are supported\n"
           exit 1
           ;;
    esac


    VERSION_FILE="${TARGET_DIR}/${TYPE}.version"
    TEMP_FILE=/tmp/update_${TYPE}.$$

    # create the configuration directory
    if [ ! -d "${TARGET_DIR}" ]; then
        printf "INFO: Making directory: %s\n" "${TARGET_DIR}"
        mkdir -p "${TARGET_DIR}"
    fi

    printf "INFO: Checking for new %s on the Java onestop page ...\n" $TYPE

    DOWNLOAD_ADDRESS="http://www.oracle.com/technetwork/java/javase/downloads/index.html"
    downloadWebsite "$DOWNLOAD_ADDRESS" "$TEMP_FILE"
    # Find the actual JRE/JDK download page
    # e.g. <a href="/technetwork/java/javase/downloads/jre10-downloads-4417026.html" target=""><img alt="Download JRE"
    #      <a align="center" target="" href="/technetwork/java/javase/downloads/sjre10-downloads-4417025.html"><img alt="Download JDK"
    #      <a href="/technetwork/java/javase/downloads/jdk10-downloads-4416644.html" target=""><img alt="Download JDK"
    REGEX='href=\"(/technetwork/java/javase/downloads/'${TYPE}'[^\"]+)\"([^>]*)>[[:space:]]*<img[[:space:]]+alt=\"Download[[:space:]]'
    parseFile "$TEMP_FILE" $REGEX

    DOWNLOAD_ADDRESS="http://www.oracle.com/${FOUND_ADDRESS}"
    downloadWebsite "$DOWNLOAD_ADDRESS" "$TEMP_FILE"
    #  Parse for the .tar.gz file
    # e.g. http://download.oracle.com/otn-pub/java/jdk/10.0.1+10/fb4372174a714e6b8c52526dc134031e/jre-10.0.1_linux-x64_bin.tar.gz
    REGEX='(http://download.oracle.com/otn-pub/java/[^_]+_'${OS_TAG}'[^\.]+\.tar.\gz)\"'
    parseFile "$TEMP_FILE" $REGEX

    DOWNLOAD_ADDRESS="${FOUND_ADDRESS}"
    THE_TAR_GZ="${TARGET_DIR}/${DOWNLOAD_ADDRESS##*/}"

    # cleanup
    rm "$TEMP_FILE" 2> /dev/null

    # Do we need to download the file actually?
    # Let's check what we have downloaded in the past
    if [ ! -f "${VERSION_FILE}" ]; then
       printf "%s\n" "none" > "${VERSION_FILE}"
    fi
    WEHAVE=$(<"${VERSION_FILE}")

    if [ "$DOWNLOAD_ADDRESS" != "$WEHAVE" ] || [ $FORCE -eq 1 ]; then
       if [ $DRYRUN -eq 1 ]; then
           printf "INFO: DRY RUN: Would download %s and would save it to %s.\n" "$DOWNLOAD_ADDRESS" "$THE_TAR_GZ"
           exit 0
       fi
       printf "Downloading %s ...\n" "$DOWNLOAD_ADDRESS"
       if [ -f "${THE_TAR_GZ}" ]; then
           rm "${THE_TAR_GZ}"
       fi
       curl -o "${THE_TAR_GZ}" -j -k -L -H "Cookie: oraclelicense=accept-securebackup-cookie" $DOWNLOAD_ADDRESS
       if [ -f "${THE_TAR_GZ}" ]; then

           printf "%s\n" "${DOWNLOAD_ADDRESS}" > "${VERSION_FILE}"

           echo "Extracting the .tar.gz file ..."
           gunzip < "${THE_TAR_GZ}" | tar xfv - -C "${TARGET_DIR}"

           # relative symlink preferred
           BACKUP=$(pwd)
           cd "${TARGET_DIR}"

           # find the java binary in the just created folder (it is faster than to search again in the .tar.gz)
           unset -v LATEST
           for FILE in $(find . -name java); do
               [[ $FILE -nt $LATEST ]] && LATEST=$FILE
           done
           # extract the path from the .../bin/java string
           LATEST=${LATEST%/*} # remove /java from the string
           LATEST=${LATEST%/*} # remove /bin from the string

           # update the symlink
           rm "${TYPE}_latest" 2> /dev/null
           ln -s $LATEST "${TYPE}_latest"

           # restore the folder
           cd "${BACKUP}"

           if [ $KEEP -eq 0 ]; then
               printf "Clean up ...\n"
               rm "${THE_TAR_GZ}"
           fi
       else
           printf "FATAL: Download failed.\n"
           exit 1
       fi
    else
       printf "Skipping download, because it seems that have downloaded %s already in the past. Use -f to force a download.\n" $DOWNLOAD_ADDRESS
    fi
}

main "$@"
